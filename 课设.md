# 计算机组成原理课程设计—8位模型CPU结构

## 一. 实验内容简介

1. 根据顶层CPU及其中各模块内部电路，用Quartus II 设计模型CPU的顶层电路原理图。
2. 对各功能模块进行仿真，给出仿真波形图，并通过详细分析这些波形，说明各模块的功能和特点及在整机系统中的作用。
3. 设计微程序，根据书本5.2节，设计对应五条指令的微程序流程图及对应的微代码表，并完成相关的mif文件。
4. 根据表5.7的应用程序，编辑对应主存地址的机器码mif文件，并通过Quartus II将这两个mif文件载入相应的存储器中。
5. 参考仿真波形图，对模型机整机在执行表5.7程序的完整过程进行仿真，并参照表5.8，将仿真波形图的所有细节给出更详细的报告。
6. 根据书本5.3.8节，利用其中介绍的所有硬件测试工具完成对模型机执行应用程序的测试，并将测试结果与波形仿真波形图仔细对照，给出报告。各测试工具的设置情况及加入主系统的电路模块也完全按照该节的介绍。
7. 编辑通信模块，将模型机运行时的信息传输至外部液晶显示器显示出来，并能通过STEP键，逐段了解CPU的运行情况，包括微指令的每一步运行情况。

## 二. 分工情况

***完成了UPC和REGS_MD模块，和顶层CPU的原理图，仿真和实验报告。

***完成了ALU_MD模块和硬件测试，单步测试的原理图，仿真和实验报告。

## 三.实验目的

1. 深入理解基本模型计算机的功能和组成知识。

2. 深入了解计算机各类典型指令的执行流程。

3. 学习微程序控制器的设计和相关技术，掌握LPM_ROM的配置方法。

4. 在掌握部件单元电路实验的基础上，进一步将单元电路组成系统，构造一台基本模型计算机。

5. 定义五条机器指令，并编写相应的微程序，上机调试，掌握计算机整机概念。

6. 掌握微程序的设计方法，学会编写二进制微指令代码表。

7. 通过完整的计算机设计，全面了解并掌握微程序控制方式计算机的设计方法。

   

## 四.实验原理

8位模型CPU结构：

此CPU主要由算术逻辑单元ALU，数据暂存寄存器DR1,DR2,数据寄存器R0~R2，程序计数器PC，地址寄存器AR，程序/数据存储器，指令寄存器IR，微控制器uC,输入单元INPUT和输出单元OUTPUT组成。

以下分别给予介绍：

1. 运算部件

   CPU中的运算器由运算部件和一部分寄存器组成。运算部分对操作数进行加工处理。

   运算部分由三部分组成：

   （1）输入逻辑：由寄存器或数据线传入，内含有两个输入缓冲寄存器，只能对两个数据进行操作；

   （2）算数、逻辑运算部件 ALU：ALU为运算部件的核心，根据用户选择需求进行不同的功能运算，还提供进位信号传递逻辑，称为进位链；

   （3）输出逻辑：运算结果可以直接送往接收部件，也可以经过左移或右移后再送往接收部件。输出逻辑具有移位功能，实现左移右移，并通过三态门，由控制信号ALU_B控制送往内部数据总线。

2. 寄存器组

   计算机工作时，CPU需要处理大量的控制信息和数据信息。例如对指令信息进行译码，以便产生相应控制命令，对操作数进行算术或逻辑运算加工，并且根据运算结果决定后续操作等。因此，在CPU中需要设置若干寄存器，暂时存放这些信息。在模型CPU中，寄存器组由ALU_MD中的R0、R1、R2组成。

3. 指令寄存器

   指令寄存器（IR）是用来存放当前正在执行的指令的，它的输出包括操作码信息、地址信息等，是产生微命令的主要逻辑依据。

4. 程序计数器

   程序计数器（PC）也被称为指令指针，用来指示指令在存储器中的存放位置。当程序顺序执行时，每取出一条指令，PC自增一次，指向下一条指令的地址。增量取决于现行指令所占的存储单元数。当程序需要转移时，就需要将地址送入PC，使PC指向新的指令地址，即JMP操作。将PC存放的后续指令地址存入到地址寄存器（AR）中，便可以从存储器中读取下一条指令。

5. 地址寄存器

   地址寄存器（AR）存放各种操作数或者指令的地址、微地址，即被访问的单元的地址。当读取指令时，CPU先将PC的内容送进AR，再由AR将指令地址送往存储器的地址线。当要读取或者存放数据时，也要先将该数据的有效地址送入AR，再对存储器进行读写操作。

6. 标志寄存器

   标志寄存器F用来记录程序的运行状态和工作方式，标志位用来反映当前程序的执行状态。一条指令执行后，CPU根据执行结果设置相应特征位，作为决定程序流向的判断依据。

   进位符：FC，产生进位则置1，否则清零

   零位：FZ，运算结果为0则置1，否则清零

7. 微命令产生部件

   根据控制信息产生微命令序列，对指令功能所要求的数据传送进行控制，同时在数据传送至运算部件时完成运算处理。

   本实验采用微程序控制方式通过微程序控制器和微指令存储器产生微命令。

8. 时序系统

   计算机工作分时分步执行，需要有一种时间信号作为分步执行的标志，如周期、节拍等。节拍是执行一个单步操作所需的时间，一个周期可能包含几个节拍。产生时序信号的部件称为时序发生器，由一组触发器组成。



设计CPU时，首先要明确机器硬件应具有哪些功能，然后根据这些功能来设置相应指令，包括确定指令格式，寻址方式和指令类型。

计算机通过执行指令来处理各种数据，为了指出数据来源，操作结果的去向及所执行的操作，一条指令应包含以下信息：

（1）操作码：说明操作的性质及功能。

（2）操作数的地址：CPU通过该地址可以获得所需的操作数。

（3）操作结果的存储地址：将操作结果存储起来，以便再次利用。

（4）下一条指令的地址：由于程序顺序执行的特性和PC计数器的存在，指令中不必明显地给出下一条要执行的指令。

一条指令实际包含了两种信息：操作码（用于表示指令要完成的操作，其长度取决于指令系统中的指令条数）和地址码（用于描述该指令的操作对象，或直接给出操作数，或指出其地址）。

在本次实验中，设计的9位CPU模型机指令系统中包含五条基本指令，分为算术运算指令，存取指令和控制转移指令三种类型。这五条机器指令分别是：IN（输入），ADD（二进制加法），STA（存数），OUT（输出），JMP（无条件转移）。

IN指令：执行指令：首先控制开关SW，运行INPUT输入装置将数据送到数据总线上，然后通过总线将输入的数据写入寄存器R0。其中包含两个步骤：SW—>BUS；BUS—>R0。执行结束程序返回取指周期，开始取下一条指令。

ADD指令：将寄存器R0的内容与存储单元内容相加后，存回寄存器R0即R0+(MEM)—>R0，执行加法运算时，需要分别将R0的内容送至寄存器DR1，将存储单元内容送至DR2，在ALU中进行加法运算后，将运算结果写回寄存器R0。存储单元地址存放在紧跟操作码的字节中，因此首先以该字节内容为地址，将其送入地址寄存器AR，然后从AR指向的RAM存储单元取出操作数送至DR2.在取指令操作码时，PC已自动加一，指向下一字节，该地址即是存放加数操作数的存储单元的地址。

STA指令：向RAM写数据操作的STA指令，以紧跟在操作码后的字节作为存放操作数的地址，将R０中的数存入该地址单元。其过程为：PC—＞AR，PC+1—>PC(以PC的内容作为取数据的地址)；

BUS<—RAM,AR<—BUS（AR指向存放操作数的RAM单元）；

R0—>BUS,BUS—>RAM(将R0内容写入该地址的RAM单元)。

OUT指令：以紧跟在操作码后的字节作为读取数据的地址，将该单元内容通过DR1输出到OUT端口。

PC—>AR,PC+1—->PC(以PC的内容作为取数据的地址)

RAM—>BUS，BUS—＞AR（AR指向存放操作数的RAM单元）

RAM—->BUS,BUS—->DR1,DR1—->OUT(将RAM单元中内容读到DR1，送往端口OUT)



## 五.实验内容和步骤

 （1）完成各模块的模型电路，并对模块功能进行测试仿真，完成仿真波形图，并通过详细分析波形，说明模块功能和特点及在整机中的作用。

**三大模块：**

#### 1. REGS_MD模块

   Mycount作为程序计数器PC用以指出下一条指令在主存中的存放地址，CPU会根据PC的内容去存取指令，而程序中的指令是顺序执行的，所以PC有自增功能，程序计数器提供下一条程序指令的地址。  

   Mycount部件verilog语言实现：

   ![image-20220106152139418](C:\Users\fairy jing\AppData\Roaming\Typora\typora-user-images\image-20220106152139418.png)

原理图：

![image-20211231100913073](C:\Users\fairy jing\AppData\Roaming\Typora\typora-user-images\image-20211231100913073.png)

为了模拟与外界总线的通信联系，此测试模块增加了一个受三态缓冲门控制的，来自外部RAM的数据总线。

REGS_MD模块中的地址寄存器AR向存储器提供地址信号，AR调用LPM_LATCH实现，模块中的其他寄存器，即指令寄存器IR和输出寄存器也都采用相同形式的锁存器担任。

> 地址寄存器AR的gate端由来自uPC模块的LDAR和来自step模块T2通过一个与门共同控制；
>
> 类似的，指令寄存器IR的gate端由来自uPC模块的LDIR和来自step模块T2通过一个与门共同控制；
>
> 输出寄存器gate端由来自uPC模块的OUT_B和来自step模块T2通过一个与门共同控制；
>
> 当收到LDAR/LDIR/OUT_B和T2的（同为高电平）脉冲信号时，打开锁存器，将BUS总线上的数据打入寄存器

程序计数器PC是第四次实验中用verilog语言自己实现计数器元器件Mycount担任的。

> 异步时序复位段clr，高电平时将PC清零，低电平时允许计数器工作,由外部输入RST复位信号控制；
>
> t4为计数时钟，由来自uPC模块的LDPC和来自step模块的T4时钟节拍通过一个与门共同控制;
>
> 数据预置同步加载端为ldpc，通过来自uPC模块的LOAD信号控制，当LOAD为低电平时，计数器正常计数，LOAD为高电平时，且始终有效时向计数器加载数据;
>
> 数据输入端data[7..0]直接与内部总线BUS[7..0]连接;
>
> 数据输出端q[7..0]通过三态门,在来自uPC模块的PC_B的控制下与内部总线相连。当PC_B的为高电平信号时且持续有效时将PC中的数据加载到BUS上。

仿真波形图：

![image-20211231103304378](C:\Users\fairy jing\AppData\Roaming\Typora\typora-user-images\image-20211231103304378.png)

分析波形：

首先给RST复位端一个脉冲信号，将PC，AR，IR，输出寄存器全部清零。

设置输入数据，模拟RAM中存储的数据。设置RAM_B,LDAR,LDIR,T2,LOAD,PC_B,LDPC,T4,OUT_B等脉冲信号。

PC:

> 当LOAD为低电平时：
>
> PC_B和LDPC在与门控制下输出高电平信号时，控制PC计数器内部数据+1。
>
> 当LOAD为高电平时始终有效时：
>
> 当LDPC和T4同时为高电平时，从BUS总线上向计数器加载数据，即PC“从03突变到27”，在CPU内部即是完成程序地址的跳转。此后LOAD为低电平且PC_B和LDPC在与门控制下输出高电平信号时，即从当前位置继续+1。

IR/AR/DOUT寄存器:

> 当LDAR与T2同时为高电平时，将BUS总线上的数据打入地址寄存器AR保存。
>
> 当LDIR与T2同时为高电平时，将BUS总线上的数据打入地址寄存器AR保存。
>
> OUT_B(在CPU顶层中应为OUT_B,在此测试模块中设置输入为LED_B)与T2同时为高电平时，将BUS总线上的数据打入输出寄存器。

BUS：

> 当RAM_B为高电平且持续有效时，将RAM中数据传入BUS总线如”25“，”26“,”27”等。
>
> 当PC_B的为高电平信号时且持续有效时将PC中的数据加载到BUS上。
>
> 如”01“，”02“，”03“等。
>
> 当两者同时为高电平向总线输入数据产生冲突时，“20”:是PC中数据”27“与RAM中数据“78”进行与运算得到的结果

#### 2. uPC模块

mc:微地址寄存器

![image-20220106163645162](C:\Users\fairy jing\AppData\Roaming\Typora\typora-user-images\image-20220106163645162.png)

cmotdemo:分支转移电路

![image-20220106163845758](C:\Users\fairy jing\AppData\Roaming\Typora\typora-user-images\image-20220106163845758.png)

decoder_C:译码器

![image-20220106164035179](C:\Users\fairy jing\AppData\Roaming\Typora\typora-user-images\image-20220106164035179.png)

测试原理图：

![image-20211231121556444](C:\Users\fairy jing\AppData\Roaming\Typora\typora-user-images\image-20211231121556444.png)



微程序控制器模块uPC是模型CPU中的重要部件，其中包括**微地址控制模块ul_C**，即分支转移控制电路，**微指令ABC字段译码电路模块decoderA,B,C**,**微操作译码器decoder_D**，**微地址寄存器uA_reg**等。

微程序控制器与外界的联系信号主要有**24位微指令M[24..1]**,接收来自指令寄存器输出的信号IR[7..0]，操作台功能选择信号SWA，SWB（在该实验中设置为高电平11，即通过操作控制台上的STEP键执行程序），分支转移及进位标志信号FC，FZ，以及大量用于微控制的控制信号。

译码器decoderA,decoderB,decoderC的作用是对24位微指令中的A,B,C字段进行指令译码。

> A字段（15，14，13）：译码后输出的信号主要用于控制向寄存器或锁存器输入数据,LDRI控制ALU模块中向目的数据寄存器存入数据;
>
> B字段（12，11，10）译码后输入的信号主要用于控制运算器，寄存器或锁存器，并通过三态缓冲门向内部数据总线输出数据;
>
> C字段（9，8，7）译码后输出的信号主要用于指令分支判断测试信号P1~4和LDPC信号。

decoderD 译码器是对24位微指令中第16位，17位进行指令译码，产生对输出装置SW，存储器RAM，输出装置LED的输出允许控制信号。****

其中uPC模块的输入信号SWA，SWB，是用于操作台工作方式选择控制。

> (SWB，SWA)=(00)：可以通过操作控制台键盘，从存储器中输出数据
>
> (SWB，SWA)=(01)：可以通过操作控制台键盘，向存储器中写入数据
>
> (SWB，SWA)=(11)：可以通过操作控制台上的STEP键，执行程序。

关于如何通过微指令的下址码经过以及C字段信号，经过分支转移控制电路，形成SE，进而由SE与下址码作用形成真正的下一条微指令的微地址：

|      | SE[6] | SE[5]    | SE[4]  | SE[3]  | SE[2]  | SE[1]  |
| ---- | ----- | -------- | ------ | ------ | ------ | ------ |
| P[1] | 1     | 1        | !IR[7] | !IR[6] | !IR[5] | !IR[4] |
| P[2] | 1     | 1        | 1      | 1      | !IR[3] | !IR[2] |
| P[3] | 1     | !(FZ+FC) | 1      | 1      | 1      | 1      |
| P[4] | 1     | 1        | 1      | 1      | !SWB   | !SWA   |

由FC，FZ，P测试，SWA，SWB信号,IR[7..2]由此表得出SE[6..1]，而SE[6..1]是微地址寄存器的输入信号，与微指令的下址字段M[6..1]，同步时钟信号T2及RST复位信号共同作用下产生下一个微地址。

RST信号为高电平时将微地址寄存器清零。

当微程序正常运行时，若SE信号所有位全部为1，则下一个微操作的微地址由微指令中字段M[6..1]直接给出，当SE信号中有0出现时，将所对应的D触发器强行置1，从而改变了下一个微操作的微地址，使微程序实现分支转移。

仿真波形图：

![image-20211231223130612](C:\Users\fairy jing\AppData\Roaming\Typora\typora-user-images\image-20211231223130612.png)

测试uPC模块：

预先存入编写好的微指令，RST复位清零，IR寄存器中从00开始，此时uA也为00，根据uA下址码从ROM中读出相应的24位微指令码018110，而当T2脉冲的出现时，根据IR寄存器中的IR[7..2]高6位控制指令操作码，控制台SWA，SWB控制信号，以及M[7..9]（当前微指令码的C字段）通过decoderC译码得到用于指令分支判断的控制信号，和状态标志FC，FZ，经过微指令分支转移控制器，得到SE[6..1]，再经过微地址寄存器根据M的低6位下址段M[6..1]以及SE，输出了相应的微地址uA[5..0]。再根据uA下址码继续读取下一次的微指令码。

（经过查表可知018110微指令的C字段是100，下址码=010000，经译码器输出为P4测试，且SWA=1,SWB=1，由上述分支转移控制电路分析可知，SE[6..1]=111100,SE对应为0的位置将下址码字段对应处强行置1，即最后得到的转移地址为：010011（23），后续步骤同理）

#### 3. ALU_MD模块

1. REG0_2模块

![image-20220106164711132](C:\Users\fairy jing\AppData\Roaming\Typora\typora-user-images\image-20220106164711132.png)

该模块为数据寄存器组，主要用于存放源操作数Rs、目的操作数Rd、运算结果和输入输出数据。

由电脉冲信号CLK、LD_R0、LD_R1、LD_R2共同控制数据输入存储到哪个寄存器中。

比如，LD_R0电信号为高电平，则来自d数组的数据存入到R0寄存器中。

2. my_alu模块

由代码实现ALU运算功能

```
module my_alu(S,A,B,F,M,CN,CO,FZ);
input[3:0] S; input[7:0] A,B; input M,CN;
output[7:0] F; output CO,FZ;
	wire[7:0] F; wire CO;wire[8:0] A9,B9;
reg FZ; reg[8:0] F9;
	assign A9={1'b0,A}; assign B9={1'b0,B};
	always @(M or CN or A9 or B9 or S) begin
	case (S)
		4'b0000 :if (M==0) F9<=A9+CN;									else F9<=~A9;
		4'b0001 :if (M==0) F9<=(A9|B9)+CN;							else F9<=~(A9|B9);
		4'b0010 :if (M==0) F9<=(A9|(~B9))+CN;						else F9<=(~A9)&B9;
		4'b0011 :if (M==0) F9<=9'b000000000-CN;					else F9<=9'b000000000;
		4'b0100 :if (M==0) F9<=A9+(A9 & ~B9)+CN;					else F9<=~(A9 & B9);
		4'b0101 :if (M==0) F9<=(A9|B9)+(A9 & ~B9)+CN;			else F9<=~B9;
		4'b0110 :if (M==0) F9<=A9-B9-CN;								else F9<=A9 ^ B9;
		4'b0111 :if (M==0) F9<=(A9 & (~B9))-CN;					else F9<=A9 &(~B9);
		4'b1000 :if (M==0) F9<=A9+(A9 & B9)+CN;					else F9<=(~A9) | B9;
		4'b1001 :if (M==0) F9<=A9+B9+CN;								else F9<=~(A9 ^ B9);
		4'b1010 :if (M==0) F9<=(A9|(~B9))+(A9 & B9)+CN;			else F9<=B9;
		4'b1011 :if (M==0) F9<=(A9 & B9)-CN;						else F9<=A9 & B9;
		//4'b0100 :if (M==0) F9<=A9+(A9 & ~B9)+CN;				else F9<=~(A9 & B9);
		
		4'b1100 :if (M==0) F9<=A9+A9+CN; 							else F9<=9'b000000001; 
		4'b1101 :if (M==0)F9<=(A9|B9)+A9+CN; 						else F9<=A9|(~B9); 
		4'b1110 :if (M==0)F9<=(A9|(~B9))+A9+CN;					else F9<=A9|B9;
		4'b1111 :if (M==0)F9<=A9-CN;									else F9<=A9;
			default:F9<=9'b000000000; 
		endcase
		if(A9==B9)FZ<=1'b0;else FZ<=1'b1 ;
	end
	assign F=F9[7:0];
assign CO=F9[8]; 
endmodule
```

后续根据不同的微操作的信号选择运算功能

3. 仿真原理图

![image-20220106164808142](C:\Users\fairy jing\AppData\Roaming\Typora\typora-user-images\image-20220106164808142.png)

4. 仿真波形图

   ![image-20220106165718724](C:\Users\fairy jing\AppData\Roaming\Typora\typora-user-images\image-20220106165718724.png)

5. ALU_MD模块仿真功能分析

   开始模拟RAM中输入的第一个操作数为D5，RAM_B为高电平，经过一个三态门，控制RAM中的数据D5进入到总线中，在T2与LDDR2信号的同时作用下，BUS总线上的数据D5载入到DR2数据暂存器中，并进入到ALU，存储在B中；

   模拟IN中输入的第二个操作数为56，SW_B为高电平，经过一个三态门，控制IN中的数据56进入到总线BUS中，同时，LD_R0为高电平，控制BUS上的56存入到寄存器R0中；

   在T2、ROC与LDDR1信号的同时作用下，REG0_2中存储在R0中的数据56进入到BUS总线上，并载入到DR1数据暂存器中；

   在LD_R0与ALU_B以及T2信号同时作用下，将R0中寄存的数据56载入到ALU中，存储在A中；

   当载入到ALU中的M数组运算控制信号变为100100（加法运算）后，ALU根据控制信号进行A和B的加法运算，56(H)+D5(h)=(1)2B(H)

   有数据溢出，FC变为高电平，ALU的运算结果从F中输出，为2B；

   在LD_R0与ALU_B以及T2信号同时作用下，ALU的计算结果进入到总线BUS上并存入到R0寄存器中。

6. ALU_MD各个信号控制分析

   LDR0_2为控制器，输出控制信号控制REG0_2

   > IR[3..0]对应从REGS_MD中输出的IR[3..0]，对应RAM中存储的微指令
   >
   > LDRI、RD_B、RJ_B控制选择LDR0、LDR1、LDR2以及R0_B、R1_B、R2_B的信号输出
   >
   > LDR0、LDR1、LDR2输出的有效电平决定d中输入的数据存储在R0、R1、R2中哪个位置上
   >
   > R0_B、R1_B、R2_B输出的有效，电平决定R0、R1、R2中的数据能否通过三态门进入总线BUS上

   REG0_2为寄存器，将数据存入R0、R1或R2中

   > d[7..0]为输入数据，从总线BUS上进入
   >
   > CLK为时钟信号，由T2控制
   >
   > LD_R0、LD_R1、LD_R2控制数据分别存入R0、R1、R2

   DR1和DR2为两个8位数据输入端的数据暂存器

   > LDDR1与LDDR2分别控制总线BUS上的数据进入两个数据暂存器DR1和DR2
   >
   > T2为两个时钟信号，共同控制决定数据的流通

   ALU181为计算器根据传入的操作数据决定数据的运算

   > M[24..21]为ROM中对应操作地址的操作码
   >
   > A[7..0]、B[7..0]为源操作数与目标操作数
   >
   > M、CN分别对应M[20]、M[19]，控制ALU的计算结果
   >
   > F[7..0]为输出的ALU计算结果
   >
   > FC为溢出判断

硬件测试原理图

![img](file:///C:/Users/fairy jing/Documents/WXWork/1688853969403784/Cache/Image/2021-12/image-20211231190130193.png)

#### **顶层CPU模块设计原理图：**

![image-20211231172728001](C:\Users\fairy jing\AppData\Roaming\Typora\typora-user-images\image-20211231172728001.png)

顶层设计仿真图：

![image-20220106162723152](C:\Users\fairy jing\AppData\Roaming\Typora\typora-user-images\image-20220106162723152.png)

![image-20220106162759306](C:\Users\fairy jing\AppData\Roaming\Typora\typora-user-images\image-20220106162759306.png)

![image-20220106162835401](C:\Users\fairy jing\AppData\Roaming\Typora\typora-user-images\image-20220106162835401.png)

![image-20220106162858229](C:\Users\fairy jing\AppData\Roaming\Typora\typora-user-images\image-20220106162858229.png)

CPU整体程序流程图分析：

开始时RST全部清零，初始时，AR=00，PC=00，uA=00,故从ROM中取出的微指令码：MC=018110。根据这一条微指令，形成下一个微地址，控制台功能判断,( SWB，SWA )=( 11 ) 执行程序，根据微地址23（没有做任何操作）形成了下一个微地址01，运行已写入的微程序：

取指阶段：

​	微地址01（微指令01ED82）：进行微操作将PC中的值通过BUS存入AR，PC++,形成下一条微地址02

​	微地址02（微指令00C048）:进行操作在RAM_B作用将RAM中的数载入BUS，在LDIR和脉冲信号的作用下将BUS上的数据载入IR指令寄存器。将指令寄存器中的操作码在uPC中进行译码，产生多条微操作，同时根据取得的指令进行p1测试形成下一条微指令的地址10.

执行第一条指令：键盘输入数据，经过BUS总线存入R０寄存器，形成下一条微地址回到０１，再进行一次取指操作如上，取出ADD操作指令。

根据此次取得的指令进行P１测试形成微操作地址，进入ＡＤＤ微操作集合：先从PC中取出下一条指令地址放入AR地址寄存器，ＰＣ＋＋。将内存(RAM)中地址对应的值取出经过BUS总线存入AR寄存器，此次取出的值是被加数的地址，需要再次从RAM中读出对应位置的值D5，经过BUS总线存入ALU_MD中的数据暂存器DR2。接着下一条微操作控制将R0(原先键盘输入数据)放入数据暂存器DR1，通过下一条微操作控制DR1和DR2的数据相加并将结果通过BUS总线存入数据寄存器R0当中。形成下一条微操作的地址为01，回到取指阶段。

同理取得下一条指令STA [0BH],并进入STA微操作集合：同样先从PC中取下一条指令地址放入AR中，ＰＣ＋＋。将内存(RAM)中地址对应的操作数地址取出经过BUS总线存入AR寄存器，此次取出的值是0BH，然后将R0寄存器中的值通过BUS总线存入RAM中0BH地址处，形成下一条微操作的地址为01，回到取指阶段。

同理取得下一条指令OUT[0BH],并进入OUT微操作集合：同样先从PC中取下一条指令地址放入AR中，ＰＣ＋＋。将内存(RAM)中地址对应的操作数地址取出经过BUS总线存入AR寄存器，此次取出的值是0BH，然后将RAM0BH地址处的值通过BUS存入数据暂存器DR1,然后将DR1中的数据存入OUT，使之可以输出显示，形成下一条微操作的地址为01，回到取指阶段。

同理取得下一条指令JMP [08H],并进入JMP微操作集合：同样先从PC中取下一条指令地址放入AR中，ＰＣ＋＋。将内存(RAM)中地址对应的操作数地址取出经过BUS总线存入PC程序计数器，此次取出的值是00，实现程序的跳转，且形成下一条微操作的地址01，回到取指阶段，当运行到下一步取指操作时，将从00地址开始重新取指，实现程序循环。

####  硬件测试电路

原理图

![img](file:///C:/Users/fairy jing/Documents/WXWork/1688853969403784/Cache/Image/2021-12/image-20211231200823724.png)

连接好电路图，配置好接口后连接实验箱，插入液晶模块，连接好排线，下载好sof文件，按液晶屏的复位键，选择模式5，按键I复位CPU。

在电脑上调用In-System Sources and Probes Editor，选择Tools->In-System and Probes Editor。

用测试工具在线测试，点击按钮开始读数据，鼠标控制STEP脉冲的输出，观察液晶显示屏上数据的变化，与仿真数据做比较，判断实验结果是否正确，是否能成功运行。

在系统测试运行结果：

![image-20220106164843297](C:\Users\fairy jing\AppData\Roaming\Typora\typora-user-images\image-20220106164843297.png)

![image-20220106164904605](C:\Users\fairy jing\AppData\Roaming\Typora\typora-user-images\image-20220106164904605.png)

#### 单步测试电路

原理图

![img](file:///C:/Users/fairy jing/Documents/WXWork/1688853969403784/Cache/Image/2021-12/image-20211231201024350.png)

去掉JTAG_SP等相关元器件，重新配置引脚接线，下载到实验箱上，仅用实验箱进行操作，用键8控制RST，键7复位，连续按键8控制STEP脉冲，观察液晶显示数据，与仿真波形数据进行比较，判断功能运行是否正确。

运行测试结果：

![image-20220106165516773](C:\Users\fairy jing\AppData\Roaming\Typora\typora-user-images\image-20220106165516773.png)

